# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

""" Generates BUILD.bazel rules for items in the Fuchsia SDK. """

def _header():
    return """# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# DO NOT EDIT: GENERATED BY generate_sdk_build_rules

package(default_visibility = ["//visibility:public"])

"""

def get_starlark_label_list(values, package_prefix = "", target_prefix = "", target_suffix = ""):
    if not values:
        return ""

    values_str = ""
    for v in values:
        values_str += "    \"" + package_prefix + v + ":" + target_prefix + v + target_suffix + "\",\n"
    return values_str

def get_starlark_list(values, prefix = "", suffix = "", remove_prefix = ""):
    """Convert a list of string into a string that can be passed to a rule attribute."""
    if not values:
        return ""

    values_str = ""
    for v in values:
        if len(remove_prefix) > 0 and v.startswith(remove_prefix):
            v = v[len(remove_prefix):]
        values_str += "    \"" + prefix + v + suffix + "\",\n"
    return values_str

def get_starlark_dict(entries):
    """Convert a dict of (string=string or list) into a string that can be passed to a rule attribute."""
    if not entries:
        return ""

    entries_str = ""
    for k in entries.keys():
        v = entries[k]
        if type(v) == "list":
            v_str = "[" + get_starlark_list(v).replace("\n", "") + "]"
        else:
            v_str = "\"" + v + "\""
        entries_str += "    \"" + k + "\": " + v_str + ",\n"
    return "{" + entries_str + "}"

def _template_path(ctx, template):
    return ctx.path(ctx.attr._template_directory).dirname.get_child(template)

def _generate_bind_library_build_rules(ctx, meta, build_file):
    tmpl = _template_path(ctx, "bind_library_template.BUILD")
    lib_base_path = meta["root"] + "/"
    _merge_template(
        ctx,
        build_file,
        tmpl,
        {
            "{{deps}}": get_starlark_list(meta["deps"], "//bind/"),
            "{{name}}": meta["name"],
            "{{sources}}": get_starlark_list(meta["sources"], remove_prefix = lib_base_path),
        },
    )

def _generate_host_tool_build_rules(ctx, meta, build_file):
    tmpl = _template_path(ctx, "host_tool_template.BUILD")
    files_str = []
    if "files" in meta:
        files_str.extend(meta["files"])
    elif "target_files" in meta:
        for arch in meta["target_files"]:
            files_str.extend(meta["target_files"][arch])

    files = []
    for file in files_str:
        relative_file = file[len(meta["root"]) + 1:]
        files.append(relative_file)

    _merge_template(
        ctx,
        build_file,
        tmpl,
        {
            "{{files}}": get_starlark_list(files),
        },
    )

def _generate_fidl_library_build_rules(ctx, meta, build_file):
    tmpl = _template_path(ctx, "fidl_library_template.BUILD")
    lib_base_path = meta["root"] + "/"

    _merge_template(
        ctx,
        build_file,
        tmpl,
        {
            "{{deps}}": get_starlark_list(meta["deps"], "//fidl/"),
            "{{name}}": meta["name"],
            "{{sources}}": get_starlark_list(meta["sources"], remove_prefix = lib_base_path),
            "{{cc_deps}}": get_starlark_label_list(meta["deps"], "//fidl/", "", "_cc"),
            "{{llcpp_deps}}": get_starlark_label_list(meta["deps"], "//fidl/", "", "_llcpp_cc"),
            "{{banjo_deps}}": get_starlark_label_list(meta["deps"], "//fidl/", "", "_banjo_cc"),
        },
    )

def _generate_cc_source_library_build_rules(ctx, meta, build_file):
    tmpl = _template_path(ctx, "cc_library_template.BUILD")
    lib_base_path = meta["root"] + "/"
    fidl_deps = []
    if "fidl_deps" in meta:
        for dep in meta["fidl_deps"]:
            fidl_deps.append("//fidl/" + dep + ":" + dep + "_cc")

    if "banjo_deps" in meta:
        for dep in meta["banjo_deps"]:
            fidl_deps.append("//fidl/" + dep + ":" + dep + "_banjo_cc")

    _merge_template(
        ctx,
        build_file,
        tmpl,
        {
            "{{deps}}": get_starlark_list(meta["deps"], "//pkg/"),
            "{{fidl_deps}}": get_starlark_list(fidl_deps),
            "{{name}}": meta["name"],
            "{{sources}}": get_starlark_list(meta["sources"], remove_prefix = lib_base_path),
            "{{headers}}": get_starlark_list(meta["headers"], remove_prefix = lib_base_path),
            "{{relative_include_dir}}": meta["include_dir"][len(lib_base_path):],
        },
    )

def _map_clang_arch(arch):
    map = {
        "x64": "@fuchsia_clang//:x86_build",
        "arm64": "@fuchsia_clang//:arm_build",
    }
    return map[arch]

def _generate_cc_prebuilt_library_build_rules(ctx, meta, build_file):
    tmpl = _template_path(ctx, "cc_prebuilt_library_template.BUILD")
    tmpl_linklib = _template_path(ctx, "cc_prebuilt_library_linklib_subtemplate.BUILD")
    tmpl_distlib = _template_path(ctx, "cc_prebuilt_library_distlib_subtemplate.BUILD")
    lib_base_path = meta["root"] + "/"
    subs = {
        "{{deps}}": get_starlark_list(meta["deps"], "//pkg/"),
        "{{name}}": meta["name"],
        "{{headers}}": get_starlark_list(meta["headers"], remove_prefix = lib_base_path),
        "{{relative_include_dir}}": meta["include_dir"][len(lib_base_path):],
    }

    prebuilt_select = {}
    dist_select = {}
    for arch in meta["binaries"]:
        _merge_template(ctx, build_file, tmpl_linklib, {
            "{{arch}}": arch,
            "{{link_lib}}": "//:" + meta["binaries"][arch]["link"],
            "{{library_type}}": meta["format"],
        })
        prebuilt_select[_map_clang_arch(arch)] = [":" + arch + "_prebuilts"]
        if "dist" in meta["binaries"][arch]:
            _merge_template(ctx, build_file, tmpl_distlib, {
                "{{arch}}": arch,
                "{{dist_lib}}": "//:" + meta["binaries"][arch]["dist"],
                "{{dist_path}}": meta["binaries"][arch]["dist_path"],
            })
            dist_select[_map_clang_arch(arch)] = [":" + arch + "_dist"]

    prebuilt_select_str = "[]"
    dist_select_str = "[]"
    if prebuilt_select:
        prebuilt_select_str = "fuchsia_select(" + get_starlark_dict(prebuilt_select) + ")"
    if dist_select:
        dist_select_str = "fuchsia_select(" + get_starlark_dict(dist_select) + ")"

    subs.update({
        "{{prebuilt_select}}": prebuilt_select_str,
        "{{dist_select}}": dist_select_str,
    })
    _merge_template(ctx, build_file, tmpl, subs)

def _merge_template(ctx, target_build_file, template_file, subs):
    if ctx.path(target_build_file).exists:
        existing_content = ctx.read(target_build_file)
    else:
        existing_content = ""

    ctx.template(target_build_file, template_file, subs)

    if existing_content != "":
        new_content = ctx.read(target_build_file)
        ctx.file(target_build_file, content = existing_content + "\n" + new_content)

def _process_dir(ctx, dir, libraries):
    generators = {
        "fidl_library": _generate_fidl_library_build_rules,
        "host_tool": _generate_host_tool_build_rules,
        "cc_source_library": _generate_cc_source_library_build_rules,
        "cc_prebuilt_library": _generate_cc_prebuilt_library_build_rules,
        "bind_library": _generate_bind_library_build_rules,
    }

    build_file = dir.get_child("BUILD.bazel")
    if build_file.exists:
        return

    ctx.file(build_file, content = _header())

    for meta in libraries:
        if "type" in meta and meta["type"] in generators:
            generator = generators[meta["type"]]
            generator(ctx, meta, build_file)

def generate_sdk_build_rules(ctx, manifests):
    """ Generates BUILD.bazel rules from the sdk metadata

    Args:
        ctx: the repository context
        manifests: a list of paths to the meta data manifests.
    """
    dir_to_meta = {}
    for manifest in manifests:
        json_obj = json.decode(ctx.read(manifest))

        # Collect all of the parts into a mapping for later templating. We need to
        # collect these here since we need to apply special logic to certain types
        # and cannot just generically apply templating to all types.
        for part in json_obj["parts"]:
            meta_file = part["meta"]
            meta = json.decode(ctx.read(meta_file))
            if "root" in meta:
                dir = ctx.path(meta["root"])
            else:
                dir = ctx.path(meta_file).dirname

            # we need to group all meta files per root directory, but only process each file once
            if dir in dir_to_meta:
                dir_to_meta[dir][meta_file] = meta
            else:
                dir_to_meta[dir] = {meta_file: meta}

    for dir in dir_to_meta.keys():
        _process_dir(ctx, dir, dir_to_meta[dir].values())
