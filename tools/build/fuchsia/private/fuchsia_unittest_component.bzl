# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

load(":providers.bzl", "FuchsiaComponentInfo", "FuchsiaPackageResourceGroupInfo", "FuchsiaPackageResourceInfo")
load(":fuchsia_component.bzl", "fuchsia_component_manifest")

def _fuchsia_unittest_component_impl(ctx):
    resources = []
    has_single_bin = False
    for dep in ctx.attr.deps:
        if FuchsiaPackageResourceInfo in dep:
            resources.append(dep[FuchsiaPackageResourceInfo])
        elif FuchsiaPackageResourceGroupInfo in dep:
            for r in dep[FuchsiaPackageResourceGroupInfo].resources:
                resources.append(r)
        elif DefaultInfo in dep:
            for mapping in dep[DefaultInfo].data_runfiles.root_symlinks.to_list():
                resources.append(FuchsiaPackageResourceInfo(src = mapping.target_file, dest = mapping.path))

            for f in dep[DefaultInfo].files.to_list():
                if f.extension == "so" or f.basename.find(".so.") > 0:
                    dest = "lib/" + f.basename
                else:
                    if has_single_bin:
                        fail("Unit test component can only have a single binary dependency.")
                    has_single_bin = True
                    dest = "bin/" + ctx.attr.test_name

                resources.append(FuchsiaPackageResourceInfo(src = f, dest = dest))

    return [
        FuchsiaComponentInfo(
            manifest = ctx.file.manifest,
            resources = resources,
        ),
    ]

# Runs fidlgen to produce the header files.
_fuchsia_unittest_component = rule(
    implementation = _fuchsia_unittest_component_impl,
    attrs = {
        "test_name": attr.string(
            doc = "The name of the test binary.",
        ),
        "deps": attr.label_list(
            doc = "The list of dependencies this test component depends on",
        ),
        "manifest": attr.label(
            doc = "The component manifest file. If not present, one will be generated.",
            allow_single_file = [".cm", ".cmx"],
            mandatory = True,
        ),
    },
)

def fuchsia_unittest_component(name, deps, test_name = None, manifest = None, **kwargs):
    """Defines a component that launches a test.

    See: https://fuchsia.dev/fuchsia-src/development/components/build

    This template is a useful shortcut for defining classic unit tests for target
    devices, where you have multiple test targets and want to bundle them in a
    single test package.
    Pure unit tests don't require any special capabilities, so their component
    manifest can be generated by the template if a manifest is not specified.
    """

    _test_name = test_name or name
    _manifest_gen = "_" + _test_name + "_autogen_manifest"

    if not manifest:
        # create a manifest file from a template
        fuchsia_component_manifest(
            name = _manifest_gen,
            component_name = _test_name,
            # TODO: move the static manifest content below to a template file
            content = """
                {
                    program: {
                        runner: 'elf_test_runner',
                        binary: 'bin/""" + _test_name + """',
                    },
                    capabilities: [
                        { protocol: "fuchsia.test.Suite" },
                    ],
                    expose: [
                        {
                            protocol: "fuchsia.test.Suite",
                            from: "self",
                        },
                    ],
                }
            """,
        )
        manifest = ":" + _manifest_gen

    _fuchsia_unittest_component(
        name = name,
        test_name = _test_name,
        manifest = manifest,
        deps = deps,
        testonly = True,
    )
